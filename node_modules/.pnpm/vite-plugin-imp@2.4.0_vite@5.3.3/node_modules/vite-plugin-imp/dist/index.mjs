import * as parser from '@babel/parser';
import Generate from '@babel/generator';
import chalk from 'chalk';
import { paramCase } from 'param-case';
import { Module, createRequire as createRequire$1 } from 'module';
import * as path from 'path';
import * as fs from 'fs';
import { pascalCase } from 'pascal-case';

const generate = typeof Generate === "function" ? Generate : Generate.default;
const createRequire = Module.createRequire || Module.createRequireFromPath;
function getType(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1);
}
const identity = (v) => v;
const isArray = Array.isArray;
const isString = (obj) => typeof obj === "string";
const isBoolean = (obj) => typeof obj === "boolean";
const isRegExp = (obj) => getType(obj) === "RegExp";
function parseImportModule(code, libList, command) {
  const ast = parser.parse(code, {
    sourceType: "module",
    plugins: [
      "jsx"
    ]
  });
  const astBody = ast.program.body;
  const importMaps = {};
  const toBeRemoveIndex = [];
  let newImportStatement = "";
  astBody.forEach((astNode, index) => {
    if (astNode.type !== "ImportDeclaration") {
      return;
    }
    const libName = astNode.source.value;
    const matchLib = libList.find((lib) => lib.libName === libName);
    if (!matchLib) {
      return;
    }
    if (astNode.specifiers.length === 0) {
      warn(`Can't transform ${generate(astNode).code}`);
      return;
    }
    const {
      camel2DashComponentName = true,
      libDirectory = "es",
      replaceOldImport = command === "build",
      nameFormatter = identity
    } = matchLib;
    astNode.specifiers.forEach((item) => {
      if (item.type === "ImportNamespaceSpecifier") {
        warn(`Can't transform ${generate(astNode).code}`);
        return;
      }
      const name = item.type === "ImportDefaultSpecifier" ? "default" : item.imported.type === "Identifier" ? item.imported.name : item.imported.value;
      const localName = item.local.name;
      const libDir = libDirectory ? `${libDirectory}/` : "";
      if (replaceOldImport) {
        const finalName = nameFormatter(camel2DashComponentName ? paramCase(name) : name, name);
        newImportStatement += `import ${localName} from '${libName}/${libDir}${finalName}';`;
        toBeRemoveIndex.push(index);
      }
      if (importMaps[libName]) {
        importMaps[libName].push(name);
      } else {
        importMaps[libName] = [name];
      }
    });
  });
  ast.program.body = astBody.filter((item, index) => !toBeRemoveIndex.includes(index));
  let codeRemoveOriginImport = generate(ast).code;
  codeRemoveOriginImport = `${newImportStatement} ; ${codeRemoveOriginImport}`;
  return { importMaps, codeRemoveOriginImport };
}
const codeIncludesLibraryName = (code, libList) => {
  return !libList.every(({ libName }) => {
    return !new RegExp(`('${libName}')|("${libName}")`).test(code);
  });
};
const stylePathNotFoundHandler = (stylePath, ignoreStylePathNotFound) => {
  if (ignoreStylePathNotFound) {
    let stylePathExists = true;
    try {
      createRequire(process.cwd() + path.sep).resolve(stylePath);
    } catch (error) {
      stylePathExists = error?.code !== "MODULE_NOT_FOUND";
    }
    if (!stylePathExists) {
      const fullStylePath = path.resolve(process.cwd(), "node_modules", stylePath);
      const lastPath = fullStylePath.split("/").pop();
      if (!lastPath?.includes(".")) {
        const possibleEndWithsPaths = [
          "/index.js",
          "/index.mjs",
          ".js",
          ".mjs"
        ];
        if (possibleEndWithsPaths.some((p) => fs.existsSync(fullStylePath + p))) {
          stylePathExists = true;
        }
      }
    }
    if (stylePathExists) {
      return `import '${stylePath}';`;
    } else {
      warn(`${stylePath} is not found!`);
      warn("If you think this is a bug, feel free to open an issue on https://github.com/onebay/vite-plugin-imp/issues");
      return "";
    }
  }
  return `import '${stylePath}';`;
};
const stylePathHandler = (stylePath, ignoreStylePathNotFound = true) => {
  let str = "";
  if (isString(stylePath) && stylePath) {
    str += stylePathNotFoundHandler(stylePath, ignoreStylePathNotFound);
  } else if (isArray(stylePath)) {
    stylePath.forEach((item) => {
      str += stylePathNotFoundHandler(item, ignoreStylePathNotFound);
    });
  }
  return str;
};
const analyzeCode = (code, impConfig, command, ignoreStylePathNotFound) => {
  const { importMaps, codeRemoveOriginImport } = parseImportModule(code, impConfig.libList, command);
  let importStr = "";
  impConfig.libList.forEach(({ libName, style = () => false, camel2DashComponentName = true }) => {
    if (importMaps[libName]) {
      importMaps[libName].forEach((item) => {
        if (camel2DashComponentName) {
          item = paramCase(item);
        }
        let stylePath = style(item);
        const styleImportString = stylePathHandler(stylePath, ignoreStylePathNotFound);
        importStr += styleImportString;
      });
    }
  });
  return {
    importStr,
    codeRemoveOriginImport
  };
};
const log = (...args) => {
  args[0] = `${chalk.green("[vite-plugin-imp]")} ${args[0]}`;
  console.log(...args);
};
const warn = (...args) => {
  args[0] = `${chalk.yellow("[vite-plugin-imp]")} ${args[0]}`;
  console.log(...args);
};
const isTranspileDependencies = (transpileDependencies, id) => {
  if (isBoolean(transpileDependencies))
    return transpileDependencies;
  if (isArray(transpileDependencies)) {
    for (const item of transpileDependencies) {
      if (isString(item) && id.includes(item) || isRegExp(item) && item.test(id)) {
        return true;
      }
    }
  }
  return false;
};

const AntdMobileReactResolver = {
  libName: "antd-mobile",
  libDirectory: "es/components"
};

const AntdResolver = {
  libName: "antd",
  style(name) {
    return `antd/es/${name}/style/css.js`;
  }
};

const AntDesignVueResolver = {
  libName: "ant-design-vue",
  style: (name) => `ant-design-vue/es/${name}/style/css.js`
};

const ArcoDesignReactResolver = {
  libName: "@arco-design/web-react",
  style: (name) => `@arco-design/web-react/es/${name}/style/css.js`
};

const matchComponents = [
  {
    pattern: /^AnchorLink$/,
    componentDir: "anchor"
  },
  {
    pattern: /^AvatarGroup$/,
    componentDir: "avatar"
  },
  {
    pattern: /^BreadcrumbItem$/,
    componentDir: "breadcrumb"
  },
  {
    pattern: /^ButtonGroup$/,
    componentDir: "button"
  },
  {
    pattern: /^(CardMeta|CardGrid)$/,
    componentDir: "card"
  },
  {
    pattern: /^CarouselItem$/,
    componentDir: "carousel"
  },
  {
    pattern: /^CheckboxGroup$/,
    componentDir: "checkbox"
  },
  {
    pattern: /^CollapseItem$/,
    componentDir: "collapse"
  },
  {
    pattern: /^(WeekPicker|MonthPicker|YearPicker|QuarterPicker|RangePicker)$/,
    componentDir: "date-picker"
  },
  {
    pattern: /^(Doption|Dgroup|Dsubmenu)$/,
    componentDir: "dropdown"
  },
  {
    pattern: /^FormItem$/,
    componentDir: "form"
  },
  {
    pattern: /^(Col|Row)$/,
    componentDir: "grid"
  },
  {
    pattern: /^(ImagePreview|ImagePreviewGroup)$/,
    componentDir: "image"
  },
  {
    pattern: /^(InputGroup|InputSearch|InputPassword)$/,
    componentDir: "input"
  },
  {
    pattern: /^(LayoutHeader|LayoutContent|LayoutFooter|LayoutSider)$/,
    componentDir: "layout"
  },
  {
    pattern: /^(ListItem|ListItemMeta)$/,
    componentDir: "list"
  },
  {
    pattern: /^(MenuItem|MenuItemGroup|SubMenu)$/,
    componentDir: "menu"
  },
  {
    pattern: /^RadioGroup$/,
    componentDir: "radio"
  },
  {
    pattern: /^(Option|Optgroup)$/,
    componentDir: "select"
  },
  {
    pattern: /^(SkeletonLine|SkeletonShape)$/,
    componentDir: "table"
  },
  {
    pattern: /^Countdown$/,
    componentDir: "statistic"
  },
  {
    pattern: /^Step$/,
    componentDir: "steps"
  },
  {
    pattern: /^(Thead|Td|Th|Tr|Tbody|TableColumn)$/,
    componentDir: "table"
  },
  {
    pattern: /^TabPane$/,
    componentDir: "tabs"
  },
  {
    pattern: /^TimelineItem$/,
    componentDir: "timeline"
  },
  {
    pattern: /^(TypographyParagraph|TypographyTitle|TypographyText)$/,
    componentDir: "typography"
  }
];
const notComponents = ["AddI18nMessages", "GetLocale", "UseLocale"];
const ArcoDesignVueResolver = {
  libName: "@arco-design/web-vue",
  replaceOldImport: false,
  style(name) {
    let styleDir = name;
    for (const item of notComponents) {
      if (item === pascalCase(name)) {
        return false;
      }
    }
    for (const item of matchComponents) {
      if (item.pattern.test(pascalCase(name))) {
        styleDir = item.componentDir;
        break;
      }
    }
    return `@arco-design/web-vue/es/${styleDir}/style/css.js`;
  }
};

const ElementPlusResolver = {
  libName: "element-plus",
  libDirectory: "es/components",
  nameFormatter: (name) => {
    return name.replace("el-", "");
  },
  style: (name) => {
    if (["el-config-provider", "effect"].includes(name))
      return false;
    return `element-plus/es/components/${name.replace("el-", "")}/style/css.js`;
  }
};

const components = [
  "ElAlert",
  "ElAside",
  "ElAutocomplete",
  "ElBadge",
  "ElBreadcrumb",
  "ElBreadcrumbItem",
  "ElButton",
  "ElButtonGroup",
  "ElCard",
  "ElCarousel",
  "ElCarouselItem",
  "ElCascader",
  "ElCheckbox",
  "ElCheckboxButton",
  "ElCheckboxGroup",
  "ElCol",
  "ElCollapse",
  "ElCollapseItem",
  "ElColorPicker",
  "ElContainer",
  "ElDatePicker",
  "ElDialog",
  "ElDropdown",
  "ElDropdownItem",
  "ElDropdownMenu",
  "ElFooter",
  "ElForm",
  "ElFormItem",
  "ElHeader",
  "ElInput",
  "ElInputNumber",
  "ElLoading",
  "ElMain",
  "ElMenu",
  "ElMenuItem",
  "ElMenuItemGroup",
  "ElMessage",
  "ElMessageBox",
  "ElNotification",
  "ElOption",
  "ElOptionGroup",
  "ElPagination",
  "ElPopover",
  "ElProgress",
  "ElRate",
  "ElRadio",
  "ElRadioButton",
  "ElRadioGroup",
  "ElRow",
  "ElSelect",
  "ElSlider",
  "ElStep",
  "ElSteps",
  "ElSubmenu",
  "ElSwitch",
  "ElTable",
  "ElTableColumn",
  "ElTag",
  "ElTabs",
  "ElTabPane",
  "ElTimeline",
  "ElTimelineItem",
  "ElTimePicker",
  "ElTimeSelect",
  "ElTooltip",
  "ElTransfer",
  "ElTree",
  "ElUpload",
  "ElLink",
  "ElDivider",
  "ElIcon",
  "ElCalendar",
  "ElImage",
  "ElBacktop",
  "ElInfiniteScroll",
  "ElPageHeader",
  "ElAvatar",
  "ElDrawer",
  "ElPopconfirm",
  "ElSkeleton",
  "ElSkeletonItem",
  "ElCascaderPanel",
  "ElEmpty",
  "ElSpinner",
  "ElDescriptions",
  "ElDescriptionsItem",
  "ElResult"
];
const ElementUIResolver = {
  libName: "element-ui",
  libDirectory: "lib",
  style(name) {
    if (components.includes(pascalCase(`el-${name}`))) {
      return `element-ui/lib/theme-chalk/${name}.css`;
    }
    return false;
  }
};

const ViewUIResolver = {
  libName: "view-design",
  libDirectory: "src/components",
  replaceOldImport: true
};

const LodashResolver = {
  libName: "lodash",
  libDirectory: "",
  camel2DashComponentName: false
};

const UnderScoreResolver = {
  libName: "underscore",
  libDirectory: "module",
  camel2DashComponentName: false
};

const VantResolver = {
  libName: "vant",
  replaceOldImport: false,
  style: (name) => `vant/es/${name}/style/index`
};

const VuetifyResolver = {
  libName: "vuetify",
  libDirectory: "lib/components",
  replaceOldImport: true,
  style: () => false,
  camel2DashComponentName: false
};

const defaultLibList = [
  AntdMobileReactResolver,
  AntdResolver,
  AntDesignVueResolver,
  ArcoDesignReactResolver,
  ArcoDesignVueResolver,
  ElementPlusResolver,
  ElementUIResolver,
  ViewUIResolver,
  LodashResolver,
  UnderScoreResolver,
  VantResolver,
  VuetifyResolver
];

const optionsCheck = (options) => {
  if (options?.libList && !Array.isArray(options?.libList)) {
    log(chalk.yellow(`libList is Array, please check your options!`));
    return false;
  }
  return true;
};
function vitePluginImp(userConfig = {}) {
  let viteConfig;
  let config;
  let isSourcemap = false;
  const name = "vite-plugin-imp";
  if (!optionsCheck(userConfig)) {
    return { name };
  }
  return {
    name,
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
      isSourcemap = !!viteConfig.build?.sourcemap;
      config = Object.assign({
        libList: [],
        exclude: [],
        removeOriginImport: viteConfig.command === "build",
        ignoreStylePathNotFound: viteConfig.command === "serve"
      }, userConfig);
      const libListNameSet = new Set(config.libList.map((lib) => lib.libName));
      let defaultLibFilteredList = defaultLibList.filter((lib) => !config.exclude?.includes(lib.libName));
      const userPkgPath = path.resolve(viteConfig.root, "package.json");
      if (fs.existsSync(userPkgPath)) {
        const require = createRequire$1(import.meta.url);
        const userPkg = require(userPkgPath);
        if (userPkg?.dependencies) {
          defaultLibFilteredList = defaultLibFilteredList.filter((item) => userPkg?.dependencies?.[item.libName]);
        }
      }
      defaultLibFilteredList.forEach((defaultLib) => {
        if (!libListNameSet.has(defaultLib.libName)) {
          config.libList?.push(defaultLib);
          libListNameSet.add(defaultLib.libName);
        }
      });
    },
    transform(code, id) {
      const { transpileDependencies = false, removeOriginImport } = config;
      if ((!/(node_modules)/.test(id) || isTranspileDependencies(transpileDependencies, id)) && codeIncludesLibraryName(code, config.libList)) {
        const sourcemap = this?.getCombinedSourcemap();
        const { importStr, codeRemoveOriginImport } = analyzeCode(code, config, "build", config.ignoreStylePathNotFound);
        return {
          code: `${importStr};${removeOriginImport ? codeRemoveOriginImport : code}`,
          map: isSourcemap ? sourcemap : null
        };
      }
      return {
        code,
        map: null
      };
    }
  };
}

export { vitePluginImp as default };
